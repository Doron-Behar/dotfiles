# {{{1 `vinfo` $EDITOR viewing info files
vinfo(){
	$EDITOR "info://$1/$2"
}

# {{{1 `path` list all directories included in $PATH, with \n between them.
path(){
	echo "${PATH//:/\n}"
}

# {{{1 `cdg` cd into git repository (even if it's a submodule).
cdg(){
	if [ -d .git ]; then
		cd .git
	elif [ -f .git ]; then
		cd $(sed 's/gitdir: //g' .git)
	else
		echo this is not a git repository - No .git file or directory found here
	fi
}

# {{{1 `cdmn` Go to the directory the current song played by mpd is located in
cdmn(){
	cd ${MPD_MUSIC_DIR}/"$(mpc current --format "%file%" | awk -F'/' '{for (i=1; i<=NF-1; ++i) printf $i"/"}')"
}

# {{{1 `awesome-spawn` launch any program in the current awesome window
awesome-spawn(){
	local args="$@"
	awesome-client "require('awful').util.spawn_with_shell('"${args}"')"
}

# {{{1 `khardp` print a phone number of khard contact using fzf
khardp(){
	local phone_number name phone_type
	khard phone --parsable | sort -u | fzf | IFS=$'\t' read -r phone_number name phone_type
	echo $phone_number
}

# {{{1 `kharde` print an email of a khard contact using fzf
kharde(){
	local email_address name email_type
	khard email --parsable | fzf | IFS=$'\t' read -r email_address name email_type
	echo $email_address
}

# {{{1 `kdec` kdeconnect-cli with default device as first argument
kdec(){
	local device_name="$(kdeconnect-cli --list-devices | awk --assign dev_id="${_KDECONNECT_DEFAULT_DEVICE}" -F'[-|:|(|)]' '$(NF - 1) == "paired and reachable" && $(NF - 2) ~ dev_id {print $2}')"
	if [[ -z "${device_name}" ]]; then
		echo It seems the default device configured with the env variable _KDECONNECT_DEFAULT_DEVICE \(${_KDECONNECT_DEFAULT_DEVICE}\) is not reachable or not paired > /dev/stderr
		return
	else
		echo Using device:${device_name}
	fi
	kdeconnect-cli --device ${_KDECONNECT_DEFAULT_DEVICE} $@
}

# {{{1 `sms` Send a text message through kdeconnect-cli
sms(){
	local args="$@"
	local phone_number name phone_type
	khard phone --parsable | sort -u | fzf | IFS=$'\t' read -r phone_number name phone_type
	if [[ -z "${phone_number}" ]]; then
		echo No recipient was chosen >&2
		return
	else
		echo "${name}"$'\t'"${phone_number}"$'\t'"${phone_type}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
		kdec --send-sms "${args}" --destination "${phone_number}" && \
		echo sent sms message to ${name} | fribidi
	fi
}

# {{{1 `smsl` Send a text message through kdeconnect-cli to the last recipient used with sms
smsl(){
	local args="$@"
	local phone_number name phone_type
	IFS=$'\t' read -r phone_number name phone_type < ${_KDECONNECT_SMS_LAST_RECIPIENT}
	if [[ -z "${recipient}" ]]; then
		recipient="$(khardp)"
		echo "${recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
	fi
	if [[ -z "${recipient}" ]]; then
		echo No recipient was chosen >&2
		return
	else
		kdec --send-sms "${args}" --destination "${recipient}" && \
		echo sent sms message to ${name} | fribidi
	fi
}

# {{{1 `call` initiate a phone call with ssh to a termux machine with termux's command `termux-telephony-call`
call(){
	local phone_number name phone_type
	khard phone --parsable | sort -u | fzf | IFS=$'\t' read -r phone_number name phone_type
	if [[ -z "${phone_number}" ]]; then
		echo No recipient was chosen >&2
		return
	else
		echo dialing: "${name}" | fribidi
		ssh-phone termux-telephony-call \""${phone_number}"\"
	fi
}

# {{{1 `lual` toggle the presedence of local paths in $LUA_PATH
lual(){
	# if the $1 is "so" we modify the LUA_CPATH instead
	local IFS=";"
	local modification_mode="${1:-lua}"
	local path_to_modify
	if [[ "$modification_mode" == lua ]]; then
		path_to_modify="${LUA_PATH}"
	elif [[ "$modification_mode" == so ]]; then
		path_to_modify="${LUA_CPATH}"
	else
		printf 'unsupported modification mode ("%s") to LUA_* variables Use either so or lua\n' "$modification_mode" >&2
	fi
	local modified_path=()
	local paths_to_move=()
	local where_to_move_paths=start
	local pth
	local pth_index=0
	while read -d"${IFS}" -r pth; do
		if [[ "$pth" =~ "^./" ]]; then
			paths_to_move+=("$pth")
			if [[ $pth_index -lt 2 ]]; then
				where_to_move_paths=end
			fi
		else
			modified_path+=("$pth")
		fi
		pth_index=$((pth_index + 1))
	done <<< "${path_to_modify+${path_to_modify}${IFS}}" # we append an extra $IFS so we'll get the last element as well
	if [[ "$where_to_move_paths" == end ]]; then
		modified_path=("${modified_path[@]}" "${paths_to_move[@]}")
	else
		modified_path=("${paths_to_move[@]}" "${modified_path[@]}")
	fi
	local concatenated_path="$(echo "${modified_path[*]}")"
	if [[ "$modification_mode" == lua ]]; then
		LUA_PATH="$concatenated_path"
		echo LUA_PATH=$concatenated_path
	elif [[ "$modification_mode" == so ]]; then
		LUA_CPATH="$concatenated_path"
		echo LUA_CPATH=$concatenated_path
	fi
}

# {{{1 `luai` lua wrapper with inspect library callable by var `i`
luai(){
	lua -e "i=require('pl.import_into')().pretty.write" -i "$@"
}

# {{{1 `wegol` wego location updater - for caching purposes
wegol(){
	local location="$(ssh phone termux-location | jq --raw-output '. | "\(.latitude)" + "," + "\(.longitude)"')"
	echo "$location" > ~/.location.txt
	sed -i 's/\(location=\)\(.*\)/\1'"$location"'/g' ~/.wegorc
	echo location $location was written to ~/.wegorc and ~/.location.txt
}

# {{{1 `juf` shows journalctl of all given systemd units
juf(){
	eval journalctl --user --follow ${@/#/--unit }
}

# {{{1 `jsf` shows journalctl of all given systemd units
jsf(){
	eval sudo journalctl --follow ${@/#/--unit }
}

# {{{1 `mkcd` mkdir and cd to it afterwards
mkcd(){
	mkdir -p "$1" && cd "$1"
}

# {{{1 `sugit` git for root
sugit() {
	if alias git; then
		unalias git
	else
		alias git="sudo env DISPLAY= GIT_EDITOR='$SUDO_EDITOR' git -c include.path=$HOME/.config/git/config -c commit.template=$HOME/.config/git/commit.template"
	fi
}

# {{{1 `pyenv` activate python environments located in ~/.virtualenvs/
pyenv() {
	. ~/.virtualenvs/"$1"/bin/activate
}

# {{{1 `guixenv` sets up a shell with guix environment
guixenv() {
	env GUIX_ENABLE=yes zsh --login
}

# {{{1 shell specific functions
if [[ ${SHELL} =~ "zsh" ]]; then
	shell_functions="${HOME}/.zsh-functions"
elif [[ ${SHELL} =~ "bash" ]]; then
	shell_functions="${HOME}/.bash-functions"
fi
if [[ -f "${shell_functions}" ]]; then
	source "${shell_functions}"
fi

# {{{1 local functions
if [[ -f "$HOME/.local/share/zsh/functions/${TERM}" ]]; then
	source "$HOME/.local/share/zsh/functions/${TERM}"
fi
if [[ -f "$HOME/.local/share/zsh/functions/${DISPLAY}" ]]; then
	source "$HOME/.local/share/zsh/functions/${DISPLAY}"
fi
if [[ -f "$HOME/.local/share/zsh/functions/${VENDOR}" ]]; then
	source "$HOME/.local/share/zsh/functions/${VENDOR}"
fi
if [[ -f "$HOME/.local/share/zsh/functions/${OSTYPE}" ]]; then
	source "$HOME/.local/share/zsh/functions/${OSTYPE}"
fi
if [[ -f "$HOME/.local/share/zsh/functions/${HOST}" ]]; then
	source "$HOME/.local/share/zsh/functions/${HOST}"
fi
if [[ -f "$HOME/.local/share/zsh/functions/${FQDN}" ]]; then
	source "$HOME/.local/share/zsh/functions/${FQDN}"
fi
if [[ -f "$HOME/.local/share/zsh/functions/${DOMAIN}" ]]; then
	source "$HOME/.local/share/zsh/functions/${DOMAIN}"
fi

# {{{1
# vim:ft=sh:foldmethod=marker
