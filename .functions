# {{{1 `man` - make man with `less` be more colorfull
# taken from wiki.archlinux.org
man(){
	env LESS_TERMCAP_mb=$'\E[01;31m' \
	LESS_TERMCAP_md=$'\E[01;38;5;74m' \
	LESS_TERMCAP_me=$'\E[0m' \
	LESS_TERMCAP_se=$'\E[0m' \
	LESS_TERMCAP_so=$'\E[38;5;246m' \
	LESS_TERMCAP_ue=$'\E[0m' \
	LESS_TERMCAP_us=$'\E[04;38;5;146m' \
	man "$@"
}

# {{{1 `cdg` - cd into git repository (even if it's a submodule).
cdg(){
	if [ -d .git ]; then
		cd .git
	elif [ -f .git ]; then
		cd $(sed 's/gitdir: //g' .git)
	else
		echo this is not a git repository - No .git file or directory found here
	fi
}

# {{{1 `fpath` - list of paths for directories containing functions for zsh completion
fpath(){
	echo "$fpath" | sed -e 's/\ /\n/g'
}

# {{{1 `path` - list all directories included in $PATH, with \n between them.
path(){
	echo "${PATH//:/\n}"
}

# {{{1 `cdm` - Go to the directory the current song played by mpd is located in
cdm(){
	cd $MPD_MUSIC_DIR/"$(mpc current --format "%file%" | awk -F'/' '{for (i=1; i<=NF-1; ++i) printf $i"/"}')"
}

# {{{1 `ranger` - modify the regular ranger command to always include the `choosedir` option
ranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
}

# {{{1 `cdr` - cd to ranger's last visited directory
cdr(){
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `cranger` - launch ranger && cd to ranger's last visited directory
cranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `p` - bookmark navigator
# Works like ranger's bookmarks
# Usage:
# You need to use/create a bookmarks file in `.config/ranger/bookmarks` which will looks like that:
# ```
# v:/home/doron/repos/dotfiles/.config/nvim
# O:/opt
# a:/home/doron/repos/dotfiles/.config/awesome
# x:/home/doron/repos/dotfiles/.tmux
# ```
# As for this bookmarks as an example, running `p v` for instance will bring you straight to Neovim's configuration directory.
p(){
	while read -r line; do
		if [ "$1" = "$(echo "$line" | cut -d':' -f1)" ]; then
			eval cd "$(echo "$line" | cut -d':' -f2)"
		fi
	done < ~/.config/ranger/bookmarks
}

# {{{1 `awesome-spawn` launch any program in the current awesome window
awesome-spawn(){
	_arguments="$@"
	awesome-client "require('awful').util.spawn_with_shell('"${_arguments}"')"
}

# {{{1 `cdf` cd into a directory chosen with a fzf selection for _FZF_DEFAULT_COMMAND_CDF
cdf(){
	_err_message="If you where not satisfied from fzf's output, checkout the env variable _FZF_DEFAULT_COMMAND_CDG"
	_dir="$(env FZF_DEFAULT_COMMAND=$_FZF_DEFAULT_COMMAND_CDF fzf)"
	if [[ -z $_dir ]]; then
		echo $_err_message > /dev/stderr
		return
	fi
	cd "$_dir" || echo $_err_message > /dev/stderr
}

# {{{1 `cdh` cd into a directory chosen with a fzf selection for _FZF_DEFAULT_COMMAND_CDH
cdh(){
	_err_message="If you where not satisfied from fzf's output, checkout the env variable _FZF_DEFAULT_COMMAND_CDH"
	_dir="$(env FZF_DEFAULT_COMMAND=$_FZF_DEFAULT_COMMAND_CDH fzf)"
	if [[ -z $_dir ]]; then
		echo $_err_message > /dev/stderr
		return
	fi
	cd "$_dir" || echo $_err_message > /dev/stderr
}
# {{{1 `cdhs` cd into a directory chosen with a fzf selection for _FZF_DEFAULT_COMMAND_CDHS
cdhs(){
	_err_message="If you where not satisfied from fzf's output, checkout the env variable _FZF_DEFAULT_COMMAND_CDHS"
	_dir="$(env FZF_DEFAULT_COMMAND=$_FZF_DEFAULT_COMMAND_CDHS fzf)"
	if [[ -z $_dir ]]; then
		echo $_err_message > /dev/stderr
		return
	fi
	cd "$_dir" || echo $_err_message > /dev/stderr
}
# {{{1 `vif` edit with $EDITOR a file chosen with a fzf selection for _FZF_DEFAULT_COMMAND_VIF
vif(){
	_err_message="If you where not satisfied from fzf's output, checkout the env variable _FZF_DEFAULT_COMMAND_VIF"
	local _file
	_file="$(env FZF_DEFAULT_COMMAND=$_FZF_DEFAULT_COMMAND_VIF fzf)"
	if [[ -z $_file ]]; then
		echo $_err_message > /dev/stderr
		return
	fi
	eval ${EDITOR-:${VISUAL}} "$_file" || echo $_err_message > /dev/stderr
}
# {{{1 `vifs` edit with $EDITOR a file chosen with a fzf selection for _FZF_DEFAULT_COMMAND_VIFS
vifs(){
	_err_message="If you where not satisfied from fzf's output, checkout the env variable _FZF_DEFAULT_COMMAND_VIFS"
	local _file
	_file="$(env FZF_DEFAULT_COMMAND=$_FZF_DEFAULT_COMMAND_VIFS fzf)"
	if [[ -z $_file ]]; then
		echo $_err_message > /dev/stderr
		return
	fi
	eval ${EDITOR-:${VISUAL}} "$_file" || echo $_err_message > /dev/stderr
}
# {{{1 `khardp` print a phone number of khard contact using fzf
khardp(){
	_KFZF_DEFAULT_COMMAND='khard phone --parsable'
	env FZF_DEFAULT_COMMAND="${_KFZF_DEFAULT_COMMAND}" fzf | awk -F$'\t' '{print $1}'
}

# {{{1 `kharde` print an email of a khard contact using fzf
kharde(){
	_EFZF_DEFAULT_COMMAND='khard email --parsable'
	env FZF_DEFAULT_COMMAND="${_EFZF_DEFAULT_COMMAND}" fzf | awk -F$'\t' '{print $1}'
}

# {{{1 `kdec` kdeconnect-cli with default device as first argument
kdec(){
	device_name="$(kdeconnect-cli --list-devices | awk --assign dev_id="${_KDECONNECT_DEFAULT_DEVICE}" -F'[-|:|(|)]' '$(NF - 1) == "paired and reachable" && $(NF - 2) ~ dev_id {print $2}')"
	if [[ -z "${device_name}" ]]; then
		echo It seems the default device configured with the env variable _KDECONNECT_DEFAULT_DEVICE \(${_KDECONNECT_DEFAULT_DEVICE}\) is not reachable or not paired > /dev/stderr
		return
	else
		echo Using device:${device_name}
	fi
	kdeconnect-cli --device ${_KDECONNECT_DEFAULT_DEVICE} $@
}

# {{{1 `sms` Send a text message through kdeconnect-cli
sms(){
	_arguments="$@"
	_recipient="$(khardp)"
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		echo "${_recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
		kdec --send-sms "${_arguments}" --destination "${_recipient}"
	fi
}

# {{{1 `smsl` Send a text message through kdeconnect-cli to the last reciepent used with sms
smsl(){
	_arguments="$@"
	_recipient="$(cat ${_KDECONNECT_SMS_LAST_RECIPIENT})"
	if [[ -z "${_recipient}" ]]; then
		_recipient="$(khardp)"
		echo "${_recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
	fi
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		kdec --send-sms "${_arguments}" --destination "${_recipient}"
	fi
}

# {{{1 `call` initiate a phone call with ssh to a termux machine with termux's command `termux-telephony-call`
call(){
	_recipient="$(khardp)"
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		echo dialing: "${_recipient}"
		ssh-phone termux-telephony-call \""${_recipient}"\"
	fi
}

# {{{1 rvm
# Load RVM into a shell session *as a function*
if [[ -s "$HOME/.rvm/scripts/rvm" ]]; then
	source "$HOME/.rvm/scripts/rvm"
fi

# {{{1 `zrc` reload zsh completion for a given command
zrc(){
	if [[ $SHELL =~ "zsh" ]]; then
		if [[ ! -z "$1" ]]; then
			unfunction "_$1"
			autoload "_$1" && return 0
		else
			echo please use this command with an argument > /dev/stderr
			return 1
		fi
	else
		echo please use this function in zsh > /dev/stderr
		return 1
	fi
}

# {{{1 local functions
[[ -f "$HOME/.local/share/zsh/${TERM}/functions" ]] && source "$HOME/.local/share/zsh/${TERM}/functions"
[[ -f "$HOME/.local/share/zsh/${DISPLAY}/functions" ]] && source "$HOME/.local/share/zsh/${DISPLAY}/functions"
[[ -f "$HOME/.local/share/zsh/${VENDOR}/functions" ]] && source "$HOME/.local/share/zsh/${VENDOR}/functions"
[[ -f "$HOME/.local/share/zsh/${OSTYPE}/functions" ]] && source "$HOME/.local/share/zsh/${OSTYPE}/functions"
[[ -f "$HOME/.local/share/zsh/${HOST}/functions" ]] && source "$HOME/.local/share/zsh/${HOST}/functions"
[[ -f "$HOME/.local/share/zsh/${FQDN}/functions" ]] && source "$HOME/.local/share/zsh/${FQDN}/functions"
[[ -f "$HOME/.local/share/zsh/${DOMAIN}/functions" ]] && source "$HOME/.local/share/zsh/${DOMAIN}/functions"

# {{{1 modeline
# vim:ft=sh:foldmethod=marker
