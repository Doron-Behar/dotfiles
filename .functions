# {{{1 `vinfo` - $EDITOR viewing info files
vinfo(){
	$EDITOR "info://$1/$2"
}

# {{{1 `path` - list all directories included in $PATH, with \n between them.
path(){
	echo "${PATH//:/\n}"
}

# {{{1 `ranger` - modify the regular ranger command to always include the `choosedir` option
ranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
}

# {{{1 `cranger` - launch ranger && cd to ranger's last visited directory
cranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `cdr` - cd to ranger's last visited directory
cdr(){
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `cdg` - cd into git repository (even if it's a submodule).
cdg(){
	if [ -d .git ]; then
		cd .git
	elif [ -f .git ]; then
		cd $(sed 's/gitdir: //g' .git)
	else
		echo this is not a git repository - No .git file or directory found here
	fi
}

# {{{1 `cdmn` - Go to the directory the current song played by mpd is located in
cdmn(){
	cd ${MPD_MUSIC_DIR}/"$(mpc current --format "%file%" | awk -F'/' '{for (i=1; i<=NF-1; ++i) printf $i"/"}')"
}

# {{{1 `cdgo` - Toggle between residing inside the same directory linkes somewhere inside $GOPATH
cdgo(){
	# initial checks
	if [ -z $GOPATH ]; then
		echo \$GOPATH is not set >&2
		return
	fi
	if [ ! -d $GOPATH ]; then
		echo \$GOPATH is not set to a readable directory >&2
		return
	fi
	#
	# resolve $GOPATH in case it is by it-self sym-link as well
	local gopath_src="$(readlink -f "$GOPATH")/src"
	#
	# cache management of $gopath_src symlinks
	# cache prefix
	local cache_dir="${HOME}/.cache/functions"
	mkdir -p ${cache_dir}
	local cache_prefix="${cache_dir}/cdgo."
	local cache_last_modification_date="$(date +%s -r ${cache_prefix}gopath_src_links 2> /dev/null)"
	local gopath_src_last_modification_date=$(date +%s -r "$gopath_src")
	local renewing_cache symlinks readlink
	# if cache is old
	if [ -z ${cache_last_modification_date} ]; then
		renewing_cache="true"
	else
		if [[ ${cache_last_modification_date} > ${gopath_src_last_modification_date} ]]; then
			renewing_cache="false"
		else
			renewing_cache="true"
		fi
	fi
	if [[ ${renewing_cache} == "true" ]]; then
		symlinks="$(find $gopath_src -type l)"
		echo $symlinks > ${cache_prefix}gopath_src_links
	else
		symlinks="$(cat ${cache_prefix}gopath_src_links)"
	fi
	#
	# actually change directory
	#
	# Checking if we are already somewhere in ${GOPATH},
	if echo "${PWD}" | grep -q "${gopath_src}" || echo "$(pwd -P)" | grep -q "${gopath_src}"; then
		# if so, we need to change to a directory which is pointed to by the link from ${symlinks} matched against ${PWD}
		while read -r link; do
			readlink="$(readlink -f ${link})"
			if echo "${PWD}" | grep -q "${link}"; then
				cd "${readlink}"
				return
			elif echo "$(pwd -P)" | grep -q "${link}"; then
				cd "${readlink}"
				return
			fi
		done <<< "${symlinks}"
	else
		# If not, we need to change to a directory in ${symlinks}
		while read -r link; do
			readlink="$(readlink -f ${link})"
			if [[ "${PWD}" == "${readlink}" ]]; then
				cd "${link}"
				return
			elif [[ "$(pwd -P)" == "${readlink}" ]]; then
				cd ${link}
				return
			fi
		done <<< "${symlinks}"
		echo "Couldn't find a directory in \$GOPATH/src which is linked to current directory" >&2
	fi
}
# {{{1 `p` - bookmark navigator
# interact with the command line bm ranger's compatible bookmarks manager
p(){
	local dir="$(bm "$@")"
	if [[ -d "$dir" ]]; then
		cd "$dir"
	else
		print -r "$dir"
	fi
}

# {{{1 `awesome-spawn` launch any program in the current awesome window
awesome-spawn(){
	local args="$@"
	awesome-client "require('awful').util.spawn_with_shell('"${args}"')"
}

# {{{1 `khardp` print a phone number of khard contact using fzf
khardp(){
	local phone_number name phone_type
	khard phone --parsable | sort -u | fzf | IFS=$'\t' read -r phone_number name phone_type
	echo $phone_number
}

# {{{1 `kharde` print an email of a khard contact using fzf
kharde(){
	local email_address name email_type
	khard email --parsable | fzf | IFS=$'\t' read -r email_address name email_type
	echo $email_address
}

# {{{1 `kdec` kdeconnect-cli with default device as first argument
kdec(){
	local device_name="$(kdeconnect-cli --list-devices | awk --assign dev_id="${_KDECONNECT_DEFAULT_DEVICE}" -F'[-|:|(|)]' '$(NF - 1) == "paired and reachable" && $(NF - 2) ~ dev_id {print $2}')"
	if [[ -z "${device_name}" ]]; then
		echo It seems the default device configured with the env variable _KDECONNECT_DEFAULT_DEVICE \(${_KDECONNECT_DEFAULT_DEVICE}\) is not reachable or not paired > /dev/stderr
		return
	else
		echo Using device:${device_name}
	fi
	kdeconnect-cli --device ${_KDECONNECT_DEFAULT_DEVICE} $@
}

# {{{1 `sms` Send a text message through kdeconnect-cli
sms(){
	local args="$@"
	local phone_number name phone_type
	khard phone --parsable | sort -u | fzf | IFS=$'\t' read -r phone_number name phone_type
	if [[ -z "${phone_number}" ]]; then
		echo No recipient was chosen >&2
		return
	else
		echo "${name}"$'\t'"${phone_number}"$'\t'"${phone_type}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
		kdec --send-sms "${args}" --destination "${phone_number}" && \
		echo sent sms message to ${name} | fribidi
	fi
}

# {{{1 `smsl` Send a text message through kdeconnect-cli to the last recipient used with sms
smsl(){
	local args="$@"
	local phone_number name phone_type
	IFS=$'\t' read -r phone_number name phone_type < ${_KDECONNECT_SMS_LAST_RECIPIENT}
	if [[ -z "${recipient}" ]]; then
		recipient="$(khardp)"
		echo "${recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
	fi
	if [[ -z "${recipient}" ]]; then
		echo No recipient was chosen >&2
		return
	else
		kdec --send-sms "${args}" --destination "${recipient}" && \
		echo sent sms message to ${name} | fribidi
	fi
}

# {{{1 `call` initiate a phone call with ssh to a termux machine with termux's command `termux-telephony-call`
call(){
	local phone_number name phone_type
	khard phone --parsable | sort -u | fzf | IFS=$'\t' read -r phone_number name phone_type
	if [[ -z "${phone_number}" ]]; then
		echo No recipient was chosen >&2
		return
	else
		echo dialing: "${name}" | fribidi
		ssh-phone termux-telephony-call \""${phone_number}"\"
	fi
}

# {{{1 `lual` toggle the presedence of local paths in $LUA_PATH
lual(){
	local lua_path=()
	IFS=";" read -A lua_path <<<"${LUA_PATH}"
	local modified_lua_path=()
	local concatenated_lua_path pth
	if [[ "${lua_path[1]}" == "./?.lua" && "${lua_path[2]}" == "./?/init.lua" ]]; then
		for pth_index in {3..${#lua_path[@]}}; do
			modified_lua_path+=("${lua_path[$pth_index]}")
		done
		modified_lua_path+=("./?.lua")
		modified_lua_path+=("./?/init.lua")
	else
		modified_lua_path+=("./?.lua")
		modified_lua_path+=("./?/init.lua")
		for pth_index in {1..$((${#lua_path[@]} - 2))}; do
			modified_lua_path+=("${lua_path[$pth_index]}")
		done
	fi
	concatenated_lua_path="${modified_lua_path[1]}"
	for pth in "${modified_lua_path[@]:1}"; do
		concatenated_lua_path="$concatenated_lua_path;$pth"
	done
	LUA_PATH="$concatenated_lua_path"
	echo LUA_PATH=$LUA_PATH
}
# {{{1 `luaa` toggle the presence of Awesome WM paths in $LUA_PATH
luaa(){
	local lua_path=()
	IFS=";" read -A lua_path <<<"${LUA_PATH}"
	local modified_lua_path=()
	local concatenated_lua_path pth
	if [[ "$LUA_PATH" =~ "awesome" ]]; then
		for pth in "${lua_path[@]}"; do
			if [[ ! "$pth" =~ "awesome" ]]; then
				modified_lua_path+=("$pth")
			fi
		done
	else
		modified_lua_path+=("/usr/share/awesome/lib/?.lua")
		modified_lua_path+=("/usr/share/awesome/lib/?/init.lua")
		for pth in "${lua_path[@]}"; do
			modified_lua_path+=("$pth")
		done
	fi
	concatenated_lua_path="${modified_lua_path[1]}"
	for pth in "${modified_lua_path[@]:1}"; do
		concatenated_lua_path="$concatenated_lua_path;$pth"
	done
	LUA_PATH="$concatenated_lua_path"
	echo LUA_PATH=$LUA_PATH
}
# {{{1 `luai` lua wrapper with inspect library callable by var `i`
luai(){
	lua -e "i=require('inspect')" -i "$@"
}

# {{{1 `wegolu` wego location updater - for caching purposes
wegolu(){
	ssh phone termux-location | jq --raw-output '. | "\(.latitude)" + "," + "\(.longitude)"' > ~/.cache/location.txt
	cat ~/.cache/location.txt
}

# {{{1 `wegol` wego wrapper with location retrived from Android device
wegol(){
	wego -location "$(cat ~/.cache/location.txt)"
}

# {{{1 `juf` shows journalctl of all given systemd units
juf(){
	eval journalctl --user --follow ${@/#/--unit }
}

# {{{1 `jsf` shows journalctl of all given systemd units
jsf(){
	eval sudo journalctl --follow ${@/#/--unit }
}

# {{{1 rvm
# Load RVM into a shell session *as a function*
if [[ -s "$HOME/.rvm/scripts/rvm" ]]; then
	source "$HOME/.rvm/scripts/rvm"
fi

# {{{1 git for root
sugit() {
	if alias git; then
		unalias git
	else
		alias git="sudo env DISPLAY= GIT_EDITOR='$SUDO_EDITOR' git -c include.path=$HOME/.config/git/config -c commit.template=$HOME/.config/git/commit.template"
	fi
}

# {{{1 shell specific functions
if [[ ${SHELL} =~ "zsh" ]]; then
	shell_functions="${HOME}/.zsh-functions"
elif [[ ${SHELL} =~ "bash" ]]; then
	shell_functions="${HOME}/.bash-functions"
fi
if [[ -f "${shell_functions}" ]]; then
	source "${shell_functions}"
fi

# {{{1 local functions
if [[ -f "$HOME/.local/share/zsh/${TERM}/functions" ]]; then
	source "$HOME/.local/share/zsh/${TERM}/functions"
fi
if [[ -f "$HOME/.local/share/zsh/${DISPLAY}/functions" ]]; then
	source "$HOME/.local/share/zsh/${DISPLAY}/functions"
fi
if [[ -f "$HOME/.local/share/zsh/${VENDOR}/functions" ]]; then
	source "$HOME/.local/share/zsh/${VENDOR}/functions"
fi
if [[ -f "$HOME/.local/share/zsh/${OSTYPE}/functions" ]]; then
	source "$HOME/.local/share/zsh/${OSTYPE}/functions"
fi
if [[ -f "$HOME/.local/share/zsh/${HOST}/functions" ]]; then
	source "$HOME/.local/share/zsh/${HOST}/functions"
fi
if [[ -f "$HOME/.local/share/zsh/${FQDN}/functions" ]]; then
	source "$HOME/.local/share/zsh/${FQDN}/functions"
fi
if [[ -f "$HOME/.local/share/zsh/${DOMAIN}/functions" ]]; then
	source "$HOME/.local/share/zsh/${DOMAIN}/functions"
fi

# {{{1
# vim:ft=sh:foldmethod=marker
