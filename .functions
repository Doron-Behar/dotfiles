# {{{1 `man` - make man with `less` be more colorfull
# taken from wiki.archlinux.org
man(){
	env LESS_TERMCAP_mb=$'\E[01;31m' \
	LESS_TERMCAP_md=$'\E[01;38;5;74m' \
	LESS_TERMCAP_me=$'\E[0m' \
	LESS_TERMCAP_se=$'\E[0m' \
	LESS_TERMCAP_so=$'\E[38;5;246m' \
	LESS_TERMCAP_ue=$'\E[0m' \
	LESS_TERMCAP_us=$'\E[04;38;5;146m' \
	man "$@"
}

# {{{1 `fpath` - list of paths for directories containing functions for zsh completion
fpath(){
	echo "$fpath" | sed -e 's/\ /\n/g'
}

# {{{1 `path` - list all directories included in $PATH, with \n between them.
path(){
	echo "${PATH//:/\n}"
}

# {{{1 `ranger` - modify the regular ranger command to always include the `choosedir` option
ranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
}

# {{{1 `cranger` - launch ranger && cd to ranger's last visited directory
cranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `cdr` - cd to ranger's last visited directory
cdr(){
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `cdg` - cd into git repository (even if it's a submodule).
cdg(){
	if [ -d .git ]; then
		cd .git
	elif [ -f .git ]; then
		cd $(sed 's/gitdir: //g' .git)
	else
		echo this is not a git repository - No .git file or directory found here
	fi
}

# {{{1 `cdmn` - Go to the directory the current song played by mpd is located in
cdmn(){
	cd ${MPD_MUSIC_DIR}/"$(mpc current --format "%file%" | awk -F'/' '{for (i=1; i<=NF-1; ++i) printf $i"/"}')"
}

# {{{1 `_create_fzf_function`: create fzf shortcut function for common operations:
# - opening with ${EDITOR} (keys starting with `VI`) - generates function vi<suffix>
# - opening with xdg-open (keys starting with `VI`) - generates function o<suffix>
# - cd into directory (keys starting with `CD`) - generates function cd<suffix>
# This function is needed because zsh and bash have different way of handling associative
# arrays and this procedure can be shared between the two
_create_fzf_function(){
	if [[ $# != 3 ]]; then
		echo please use this function with 3 arguments > /dev/stderr
		return 2
	fi
	local key="$1"
	local fzf_cmd="$2"
	local funcname="$3"
	local cmd
	if [[ "${key}" =~ "^CD" ]]; then
		cmd="cd"
	elif [[ "${key}" =~ "^VI" ]]; then
		cmd="${EDITOR}"
	elif [[ "${key}" =~ "^O" ]]; then
		cmd="xdg-open"
	else
		echo "couldn't generate a proper function for fzf shortcut with key "${key} > /dev/stderr
		return
	fi
	cat << EOF
${funcname}(){
	local _arg="\$(env FZF_DEFAULT_COMMAND='${fzf_cmd}' fzf)";
	[[ -z "\${_arg}" ]] || ${cmd} "\${_arg}"
};
fzf_${funcname}(){
	env FZF_DEFAULT_COMMAND='${fzf_cmd}' fzf;
}
EOF
}
# {{{1 `p` - bookmark navigator
# Works like ranger's bookmarks
# Usage:
# You need to use/create a bookmarks file in `.config/ranger/bookmarks` which will looks like that:
# ```
# v:/home/doron/repos/dotfiles/.config/nvim
# O:/opt
# a:/home/doron/repos/dotfiles/.config/awesome
# x:/home/doron/repos/dotfiles/.tmux
# ```
# As for this bookmarks as an example, running `p v` for instance will bring you straight to Neovim's configuration directory.
p(){
	while read -r line; do
		if [ "$1" = "$(echo "$line" | cut -d':' -f1)" ]; then
			eval cd "$(echo "$line" | cut -d':' -f2)"
		fi
	done < ~/.config/ranger/bookmarks
}

# {{{1 `awesome-spawn` launch any program in the current awesome window
awesome-spawn(){
	_arguments="$@"
	awesome-client "require('awful').util.spawn_with_shell('"${_arguments}"')"
}

# {{{1 `khardp` print a phone number of khard contact using fzf
khardp(){
	_KFZF_DEFAULT_COMMAND='khard phone --parsable'
	env FZF_DEFAULT_COMMAND="${_KFZF_DEFAULT_COMMAND}" fzf | awk -F$'\t' '{print $1}'
}

# {{{1 `kharde` print an email of a khard contact using fzf
kharde(){
	_EFZF_DEFAULT_COMMAND='khard email --parsable'
	env FZF_DEFAULT_COMMAND="${_EFZF_DEFAULT_COMMAND}" fzf | awk -F$'\t' '{print $1}'
}

# {{{1 `kdec` kdeconnect-cli with default device as first argument
kdec(){
	device_name="$(kdeconnect-cli --list-devices | awk --assign dev_id="${_KDECONNECT_DEFAULT_DEVICE}" -F'[-|:|(|)]' '$(NF - 1) == "paired and reachable" && $(NF - 2) ~ dev_id {print $2}')"
	if [[ -z "${device_name}" ]]; then
		echo It seems the default device configured with the env variable _KDECONNECT_DEFAULT_DEVICE \(${_KDECONNECT_DEFAULT_DEVICE}\) is not reachable or not paired > /dev/stderr
		return
	else
		echo Using device:${device_name}
	fi
	kdeconnect-cli --device ${_KDECONNECT_DEFAULT_DEVICE} $@
}

# {{{1 `sms` Send a text message through kdeconnect-cli
sms(){
	_arguments="$@"
	_recipient="$(khardp)"
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		echo "${_recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
		kdec --send-sms "${_arguments}" --destination "${_recipient}"
	fi
}

# {{{1 `smsl` Send a text message through kdeconnect-cli to the last reciepent used with sms
smsl(){
	_arguments="$@"
	_recipient="$(cat ${_KDECONNECT_SMS_LAST_RECIPIENT})"
	if [[ -z "${_recipient}" ]]; then
		_recipient="$(khardp)"
		echo "${_recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
	fi
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		kdec --send-sms "${_arguments}" --destination "${_recipient}"
	fi
}

# {{{1 `call` initiate a phone call with ssh to a termux machine with termux's command `termux-telephony-call`
call(){
	_recipient="$(khardp)"
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		echo dialing: "${_recipient}"
		ssh-phone termux-telephony-call \""${_recipient}"\"
	fi
}

# {{{1 rvm
# Load RVM into a shell session *as a function*
if [[ -s "$HOME/.rvm/scripts/rvm" ]]; then
	source "$HOME/.rvm/scripts/rvm"
fi

# {{{1 shell specific functions
if [[ ${SHELL} =~ "zsh" ]]; then
	shell_functions="${HOME}/.zsh-functions"
elif [[ ${SHELL} =~ "bash" ]]; then
	shell_functions="${HOME}/.bash-functions"
fi
[[ -f "${shell_functions}" ]] && source "${shell_functions}"

# {{{1 local functions
[[ -f "$HOME/.local/share/zsh/${TERM}/functions" ]] && source "$HOME/.local/share/zsh/${TERM}/functions"
[[ -f "$HOME/.local/share/zsh/${DISPLAY}/functions" ]] && source "$HOME/.local/share/zsh/${DISPLAY}/functions"
[[ -f "$HOME/.local/share/zsh/${VENDOR}/functions" ]] && source "$HOME/.local/share/zsh/${VENDOR}/functions"
[[ -f "$HOME/.local/share/zsh/${OSTYPE}/functions" ]] && source "$HOME/.local/share/zsh/${OSTYPE}/functions"
[[ -f "$HOME/.local/share/zsh/${HOST}/functions" ]] && source "$HOME/.local/share/zsh/${HOST}/functions"
[[ -f "$HOME/.local/share/zsh/${FQDN}/functions" ]] && source "$HOME/.local/share/zsh/${FQDN}/functions"
[[ -f "$HOME/.local/share/zsh/${DOMAIN}/functions" ]] && source "$HOME/.local/share/zsh/${DOMAIN}/functions"

# {{{1
# vim:ft=sh:foldmethod=marker
