# {{{1 `man` - make man with `less` be more colorfull
# taken from wiki.archlinux.org
man(){
	env LESS_TERMCAP_mb=$'\E[01;31m' \
	LESS_TERMCAP_md=$'\E[01;38;5;74m' \
	LESS_TERMCAP_me=$'\E[0m' \
	LESS_TERMCAP_se=$'\E[0m' \
	LESS_TERMCAP_so=$'\E[38;5;246m' \
	LESS_TERMCAP_ue=$'\E[0m' \
	LESS_TERMCAP_us=$'\E[04;38;5;146m' \
	man "$@"
}

# {{{1 `vinfo` - $EDITOR viewing info files
vinfo(){
	$EDITOR "info://$1/$2"
}

# {{{1 `v` - launch $EDITOR smartly
if [[ $EDITOR =~ "nvim" ]]; then
	v(){
		local args=()
		while [[ $# -gt 0 ]]; do
			args+=("$1")
			shift
		done
		for (( i=1; i < ${#args[@]} + 1; i++ )); do
			if [[ ! ${args[$i]} =~ "^-" ]]; then
				if [[ ! -w ${args[$i]} ]]; then
					args[$i]="suda://${args[$i]}"
				fi
			fi
		done
		set -- "${args[@]}"
		$EDITOR ${args}
	}
else
	alias v=$EDITOR
fi

# {{{1 `path` - list all directories included in $PATH, with \n between them.
path(){
	echo "${PATH//:/\n}"
}

# {{{1 `ranger` - modify the regular ranger command to always include the `choosedir` option
ranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
}

# {{{1 `cranger` - launch ranger && cd to ranger's last visited directory
cranger(){
	/usr/bin/ranger --choosedir="${XDG_RUNTIME_DIR}/ranger-directory" "${@}"
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `cdr` - cd to ranger's last visited directory
cdr(){
	cd "$(cat ${XDG_RUNTIME_DIR}/ranger-directory)"
}

# {{{1 `cdg` - cd into git repository (even if it's a submodule).
cdg(){
	if [ -d .git ]; then
		cd .git
	elif [ -f .git ]; then
		cd $(sed 's/gitdir: //g' .git)
	else
		echo this is not a git repository - No .git file or directory found here
	fi
}

# {{{1 `cdmn` - Go to the directory the current song played by mpd is located in
cdmn(){
	cd ${MPD_MUSIC_DIR}/"$(mpc current --format "%file%" | awk -F'/' '{for (i=1; i<=NF-1; ++i) printf $i"/"}')"
}

# {{{1 `cdgo` - Toggle between residing inside the same directory linkes somewhere inside $GOPATH
cdgo(){
	# initial checks
	if [ -z $GOPATH ]; then
		echo \$GOPATH is not set >&2
		return
	fi
	if [ ! -d $GOPATH ]; then
		echo \$GOPATH is not set to a readable directory >&2
		return
	fi
	#
	# resolve $GOPATH in case it is by it-self sym-link as well
	gopath_src="$(readlink -f "$GOPATH")/src"
	#
	# cache management of $gopath_src symlinks
	# cache prefix
	cache_dir="${HOME}/.cache/functions"
	mkdir -p ${cache_dir}
	cache_prefix="${cache_dir}/cdgo."
	cache_last_modification_date="$(date +%s -r ${cache_prefix}gopath_src_links 2> /dev/null)"
	gopath_src_last_modification_date=$(date +%s -r "$gopath_src")
	# if cache is old
	if [ -z ${cache_last_modification_date} ]; then
		renewing_cache="true"
	else
		if [[ ${cache_last_modification_date} > ${gopath_src_last_modification_date} ]]; then
			renewing_cache="false"
		else
			renewing_cache="true"
		fi
	fi
	if [[ ${renewing_cache} == "true" ]]; then
		symlinks="$(find $gopath_src -type l)"
		echo $symlinks > ${cache_prefix}gopath_src_links
	else
		symlinks="$(cat ${cache_prefix}gopath_src_links)"
	fi
	#
	# actually change directory
	#
	# Checking if we are already somewhere in ${GOPATH},
	if echo "${PWD}" | grep -q "${gopath_src}" || echo "$(pwd -P)" | grep -q "${gopath_src}"; then
		# if so, we need to change to a directory which is pointed to by the link from ${symlinks} matched against ${PWD}
		while read -r link; do
			readlink="$(readlink -f ${link})"
			if echo "${PWD}" | grep -q "${link}"; then
				cd "${readlink}"
				return
			elif echo "$(pwd -P)" | grep -q "${link}"; then
				cd "${readlink}"
				return
			fi
		done <<< "${symlinks}"
	else
		# If not, we need to change to a directory in ${symlinks}
		while read -r link; do
			readlink="$(readlink -f ${link})"
			if [[ "${PWD}" == "${readlink}" ]]; then
				cd "${link}"
				return
			elif [[ "$(pwd -P)" == "${readlink}" ]]; then
				cd ${link}
				return
			fi
		done <<< "${symlinks}"
		echo "Couldn't find a directory in \$GOPATH/src which is linked to current directory" >&2
	fi
}
# {{{1 `p` - bookmark navigator
# interact with the command line bm ranger's compatible bookmarks manager
p(){
	dir="$(bm "$@")"
	if [[ -d "$dir" ]]; then
		cd "$dir"
	else
		print -r "$dir"
	fi
}

# {{{1 `awesome-spawn` launch any program in the current awesome window
awesome-spawn(){
	_arguments="$@"
	awesome-client "require('awful').util.spawn_with_shell('"${_arguments}"')"
}

# {{{1 `khardp` print a phone number of khard contact using fzf
khardp(){
	khard phone --parsable | uniq | fzf | awk -F$'\t' '{print $1}'
}

# {{{1 `kharde` print an email of a khard contact using fzf
kharde(){
	khard email --parsable | fzf | awk -F$'\t' '{print $1}'
}

# {{{1 `kdec` kdeconnect-cli with default device as first argument
kdec(){
	device_name="$(kdeconnect-cli --list-devices | awk --assign dev_id="${_KDECONNECT_DEFAULT_DEVICE}" -F'[-|:|(|)]' '$(NF - 1) == "paired and reachable" && $(NF - 2) ~ dev_id {print $2}')"
	if [[ -z "${device_name}" ]]; then
		echo It seems the default device configured with the env variable _KDECONNECT_DEFAULT_DEVICE \(${_KDECONNECT_DEFAULT_DEVICE}\) is not reachable or not paired > /dev/stderr
		return
	else
		echo Using device:${device_name}
	fi
	kdeconnect-cli --device ${_KDECONNECT_DEFAULT_DEVICE} $@
}

# {{{1 `sms` Send a text message through kdeconnect-cli
sms(){
	_arguments="$@"
	_recipient="$(khardp)"
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		echo "${_recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
		kdec --send-sms "${_arguments}" --destination "${_recipient}"
	fi
}

# {{{1 `smsl` Send a text message through kdeconnect-cli to the last reciepent used with sms
smsl(){
	_arguments="$@"
	_recipient="$(cat ${_KDECONNECT_SMS_LAST_RECIPIENT})"
	if [[ -z "${_recipient}" ]]; then
		_recipient="$(khardp)"
		echo "${_recipient}" > ${_KDECONNECT_SMS_LAST_RECIPIENT}
	fi
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		kdec --send-sms "${_arguments}" --destination "${_recipient}"
	fi
}

# {{{1 `call` initiate a phone call with ssh to a termux machine with termux's command `termux-telephony-call`
call(){
	_recipient="$(khardp)"
	if [[ -z "${_recipient}" ]]; then
		echo No reciepent was chosen > /dev/stderr
		return
	else
		echo dialing: "${_recipient}"
		ssh-phone termux-telephony-call \""${_recipient}"\"
	fi
}

# {{{1 rvm
# Load RVM into a shell session *as a function*
if [[ -s "$HOME/.rvm/scripts/rvm" ]]; then
	source "$HOME/.rvm/scripts/rvm"
fi

# {{{1 git for root
sugit() {
	if alias git; then
		unalias git
	else
		alias git="sudo env GIT_EDITOR='$SUDO_EDITOR' git -c include.path=$HOME/.config/git/config -c commit.template=$HOME/.config/git/commit.template"
	fi
}

# {{{1 shell specific functions
if [[ ${SHELL} =~ "zsh" ]]; then
	shell_functions="${HOME}/.zsh-functions"
elif [[ ${SHELL} =~ "bash" ]]; then
	shell_functions="${HOME}/.bash-functions"
fi
[[ -f "${shell_functions}" ]] && source "${shell_functions}"

# {{{1 local functions
[[ -f "$HOME/.local/share/zsh/${TERM}/functions" ]] && source "$HOME/.local/share/zsh/${TERM}/functions"
[[ -f "$HOME/.local/share/zsh/${DISPLAY}/functions" ]] && source "$HOME/.local/share/zsh/${DISPLAY}/functions"
[[ -f "$HOME/.local/share/zsh/${VENDOR}/functions" ]] && source "$HOME/.local/share/zsh/${VENDOR}/functions"
[[ -f "$HOME/.local/share/zsh/${OSTYPE}/functions" ]] && source "$HOME/.local/share/zsh/${OSTYPE}/functions"
[[ -f "$HOME/.local/share/zsh/${HOST}/functions" ]] && source "$HOME/.local/share/zsh/${HOST}/functions"
[[ -f "$HOME/.local/share/zsh/${FQDN}/functions" ]] && source "$HOME/.local/share/zsh/${FQDN}/functions"
[[ -f "$HOME/.local/share/zsh/${DOMAIN}/functions" ]] && source "$HOME/.local/share/zsh/${DOMAIN}/functions"

# {{{1
# vim:ft=sh:foldmethod=marker
