# create a simpler and lighter directory fzf completion
_fzf_complete_path() {
	local lbuf="$1"
	local prefix="$2"
	local mode="$3"  # string - `files` or `directories`
	local path_prefix
	if [[ "${prefix}" =~ "/" ]]; then
		path_prefix="${prefix%/*}/"
		prefix="${prefix##*/}"
	else
		path_prefix="./"
	fi
	local query="${prefix//*\//}"
	local options
	if [[ "$mode" == "directories" ]]; then
		options=(${path_prefix}*(-/)) 2> /dev/null
	elif [[ "$mode" == "files" ]]; then
		options=(${path_prefix}*) 2> /dev/null
	fi
	[ -z "${options}" ] && return 1
	local matches="$(printf '%s\n' "${options[@]}" | fzf --query="${query}" -m --preview='[[ -d {} ]] && ls --color {} || highlight --out-format=ansi --force | head -$LINES {}')"
	[ -z "$matches" ] && return 1
	if [[ -d "${matches}" ]]; then
		LBUFFER="$lbuf${(q)matches}/"
	else
		LBUFFER="$lbuf${(q)matches}"
	fi
}

# make sure cd is completed with the default fzf-completion widget with _fzf_complete_dir
_fzf_complete_cd() {
	_fzf_complete_path "$@" "directories"
}

# gopass and pass passwords
_fzf_complete_gopass() {
	local prefix="$2"
	local match="$(find -L ~/.password-store -name '.git*' -prune -o -type f -printf '%P\n' | sed 's/.gpg$//' | fzf --query="${prefix}")"
	[ -z "$match" ] && return 1
	LBUFFER="$lbuf${match}"
}
_fzf_complete_pass() {
	_fzf_complete_gopass "$@"
}

# export (zsh's built-in)
_fzf_complete_export() {
	local lbuf="$1"
	local prefix="$2"
	local var value vars values
	declare -x | while IFS="=" read var value; do
		vars+=($var)
	done
	local match="$(printf '%s\n' "${vars[@]}" | fzf --query="${prefix}" --preview='eval echo \${}')"
	[ -z "$match" ] && return 1
	LBUFFER="$lbuf${match}"
}

# unset (zsh's built-in)
_fzf_complete_unset() {
	_fzf_complete_export "$@"
}

# unalias (zsh's built-in)
_fzf_complete_unalias() {
	local lbuf="$1"
	local prefix="$2"
	local var value vars values
	alias | while IFS="=" read var value; do
		vars+=($var)
	done
	local match="$(printf '%s\n' "${vars[@]}" | fzf --query="${prefix}")"
	[ -z "$match" ] && return 1
	LBUFFER="$lbuf${match}"
}

# kill
_fzf_complete_kill() {
	local lbuf="$1"
	local prefix="$2"
	local user pid rest_of_line
	local pids=($(command ps -ef | sed 1d | fzf -m -q "$prefix" --height "50%" --min-height 15 --reverse --preview 'echo {}' --preview-window down:3:wrap | while read user pid rest_of_line; do
		echo "$pid"
	done))
	[ -z "$pids" ] && return 1
	LBUFFER="$lbuf${pids[@]}"
	zle reset-prompt
}
