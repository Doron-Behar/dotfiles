# create a simpler and lighter directory fzf completion
_fzf_complete_path() {
	local lbuf="$1"
	local prefix="$2"
	local mode="$3"  # string - `files` or `directories`
	local path_prefix
	if [[ "${prefix}" =~ "/" ]]; then
		path_prefix="${prefix%/*}/"
		prefix="${prefix##*/}"
	else
		path_prefix="./"
	fi
	# substiture ~ to $HOME in path_prefix
	path_prefix="${path_prefix/#\~/$HOME}"
	# remove \ when it is intended to quote special characters
	path_prefix="${path_prefix//\\/}"
	local query="${prefix//*\//}"
	local opts
	if [[ "$mode" == "directories" ]]; then
		opts=("${path_prefix}"*(-/)) 2> /dev/null
	elif [[ "$mode" == "files" ]]; then
		opts=("${path_prefix}"*) 2> /dev/null
	fi
	#[ -z "${opts}" ] && return 1
	local matches=(${(f)"$(printf '%s\n' "${opts[@]}" | fzf --query="${query}" -m --preview='[[ -d {} ]] && ls --color {} || ~/.config/ranger/scope.sh {} $COLUMNS $LINES "" False')"})
	#[ -z "$matches" ] && return 1
	if [[ -e "${matches}" ]]; then
		LBUFFER="$lbuf${(@q)matches}/"
	else
		LBUFFER="$lbuf${(@q)matches}"
	fi
}

# make sure cd is completed with the default fzf-completion widget with _fzf_complete_dir
_fzf_complete_cd() {
	_fzf_complete_path "$@" "directories"
}

# gopass and pass passwords
_fzf_complete_gopass() {
	local prefix="$2"
	local match="$(find -L ~/.password-store -name '.git*' -prune -o -type f -printf '%P\n' | sed 's/.gpg$//' | fzf --query="${prefix}")"
	[ -z "$match" ] && return 1
	LBUFFER="$lbuf${match}"
}
_fzf_complete_pass() {
	_fzf_complete_gopass "$@"
}

# export (zsh's built-in)
_fzf_complete_export() {
	local lbuf="$1"
	local prefix="$2"
	local var value vars values
	declare -x | while IFS="=" read var value; do
		vars+=($var)
	done
	local match="$(printf '%s\n' "${vars[@]}" | fzf --query="${prefix}" --preview='eval echo \${}')"
	[ -z "$match" ] && return 1
	LBUFFER="$lbuf${match}"
}

# unset (zsh's built-in)
_fzf_complete_unset() {
	_fzf_complete_export "$@"
}

# unalias (zsh's built-in)
_fzf_complete_unalias() {
	local lbuf="$1"
	local prefix="$2"
	local var value vars values
	alias | while IFS="=" read var value; do
		vars+=($var)
	done
	local match="$(printf '%s\n' "${vars[@]}" | fzf --query="${prefix}")"
	[ -z "$match" ] && return 1
	LBUFFER="$lbuf${match}"
}

# kill
_fzf_complete_kill() {
	local lbuf="$1"
	local prefix="$2"
	local user pid rest_of_line
	local pids=($(command ps -ef | sed 1d | fzf -m -q "$prefix" --height "50%" --min-height 15 --reverse --preview 'echo {}' --preview-window down:3:wrap | while read user pid rest_of_line; do
		echo "$pid"
	done))
	[ -z "$pids" ] && return 1
	LBUFFER="$lbuf${pids[@]}"
	zle reset-prompt
}

# juf and jsf shell functions
_fzf_complete_journal(){
	local lbuf="$1"
	local prefix="$2"
	local mode="$3"  # string - `user` or `system`
	local systemctl_cmd
	if [[ "$mode" == "user" ]]; then
		systemctl_cmd='systemctl --user'
	else
		systemctl_cmd='systemctl'
	fi
	local unit load active sub description
	local units
	local first_iteration=1 break_larger_loop=0
	eval $systemctl_cmd list-units --plain | while read unit load active sub description; do
		if (($first_iteration)); then
			first_iteration=0
			continue
		fi
		for field in "$unit" "$load" "$active" "$sub" "$description"; do
			if [[ ! -z "$field" ]]; then
				units+=("$unit")
				break
			else
				if [[ "$description" == "$field" ]]; then
					break_larger_loop=1
				fi
			fi
		done
		if (($break_larger_loop)); then
			break
		fi
	done
	local matches=($(printf '%s\n' "${units[@]}" | fzf -m --preview="$systemctl_cmd status {}"))
	[ -z "$matches" ] && return 1
	LBUFFER="$LBUFFER${matches[@]}"
}
_fzf_complete_juf(){
	_fzf_complete_journal "$@" user
}
_fzf_complete_jsf(){
	_fzf_complete_journal "$@" system
}

# man pages
_fzf_complete_man(){
	local lbuf="$1"
	local prefix="$2"
	local name section dash description
	local matches=($(man -k . | fzf -m | while read -r name section dash description; do
		echo "$name.${${section#\(}%\)}"
	done))
	[ -z "$matches" ] && return 1
	LBUFFER="$LBUFFER${matches[@]}"
}
